(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{357:function(e,t,o){"use strict";o.r(t);var s=o(20),n=Object(s.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"look-how-well-elephants-hide-in-a-rowan-tree"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#look-how-well-elephants-hide-in-a-rowan-tree"}},[e._v("#")]),e._v(" Look how well elephants hide in a rowan tree")]),e._v(" "),t("p",[e._v("More often I see GitHub Copilot tutorials with prompts like "),t("em",[e._v('"Write unit tests for this function"')]),e._v(", closer I'm to fine about my job security.")]),e._v(" "),t("p",[e._v("There's a reason why Test-Driven Development (TDD) suggests writing tests before the implementation. It's not just about writing top-down designed code. It's also about ensuring your tests are falsifiable and genuinely help in developing the code. Being able to falsify your hypothesis is the essence of engineering. And being able to falsify your tests is the essence of software engineering.")]),e._v(" "),t("p",[e._v("By the way, did you know that elephants hide in rowan trees? No? Ever seen an elephant in a rowan tree? That's how well they hide.")]),e._v(" "),t("p",[e._v('I\'ve seen this joke many times come to life in real projects. When a new team member joins, a senior developer might ask them to write a few unit tests as part of the onboarding process. But without product requirements, how do we ensure these tests properly validate the code? How do we verify that the "elephant" is truly hiding in the "rowan trees" if no one has ever seen it?”')]),e._v(" "),t("p",[e._v("If you find yourself in this situation, try using a technique called "),t("em",[e._v("mutation testing")]),e._v(". Introduce common mistakes into your implementation to ensure your tests fail. Also, make some neutral modifications that shouldn't cause your tests to fail. If they do fail, it means your tests are too tightly coupled with the implementation, and you should improve your interfaces by writing better tests first. These will show you false positives and false negatives of your test cases.")]),e._v(" "),t("p",[e._v("Not writing tests before your code is like taking on technical debt mortgage. Don't get me wrong, though. It's still not as terrible as generating tons of AI tests after the implementation that no one will read, which is like taking out a loan with horrendous interest rates. That could actually drown your project. I'm not surprised that people are reluctant to write tests if they're taught to write them afterwards. Also, to modules that don't return anything, which forces them to use mocks to check internal state of tested code. What’s the benefit of these tests if they don’t describe Product Requirements Documents (PRDs) or help in designing interfaces, or writing the implementation?")]),e._v(" "),t("p",[e._v("I can assure you about one thing. Write tests before the implementation, use stubs over mocks, always return something from your functions, and you'll have fewer side effects. You'll have to check internal behaviour less often, your tests will be easier to maintain in long term, and you'll save more time.")]),e._v(" "),t("h2",{attrs:{id:"references"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),t("ul",[t("li",[t("em",[e._v("Mutation testing")]),e._v(", "),t("a",{attrs:{href:"https://en.wikipedia.org/wiki/Mutation_testing",target:"_blank",rel:"noopener noreferrer"}},[e._v("online"),t("OutboundLink")],1),e._v(".")])]),e._v(" "),t("p",[t("em",[e._v("Article was originally written 2025.01.03")])])])}),[],!1,null,null,null);t.default=n.exports}}]);